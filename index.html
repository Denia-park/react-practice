<!DOCTYPE html>
<html>
    <body>
        <div id="root"></div>
    </body>
    <script src="https://unpkg.com/react@17.0.2/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17.0.2/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel">
        const root = document.getElementById('root')

        // function Btn(props) => {props.banana} , props 는 object 이다.
        function Btn({ text, changeValue }) {
            console.log(text, 'was changed')
            return (
                <button
                    onClick={changeValue}
                    style={{
                        backgroundColor: 'tomato',
                        color: 'white',
                        padding: '10px 20px',
                        border: 0,
                        borderRadius: 10,
                        fontSize: 16,
                    }}>
                    {text}
                </button>
            )
        }

        //React의 규칙에 의해서
        //만약 컴포넌트가 상태를 바꾼다면 다시 render 한다.

        //우리는 React.memo 를 사용해서 컴포넌트를 다시 그릴지 어떨지 결정할 수 있다. [prop가 변경되지 않는 한에서]
        //우리는 React에게 "만약 이 props가 변경되지 않는다면 다시 그릴 필요가 없다는 것을 말해줬다.
        // "만약 props가 변한다면, 뭐, 제발 우리 Btn을 다시 그려주세요"
        const MemorizedBtn = React.memo(Btn)

        //만약 부모가 어떤 state라도 변경이 있다? 모든 자식들은 다시 그려진다.
        //그리고 이게 추후에 네 앱이 느려지는 원인이 될 수 있다.

        function App() {
            const [value, setValue] = React.useState('Save Changes')
            const changeValue = () => setValue('Revert Changes')
            return (
                <div>
                    <MemorizedBtn text={value} changeValue={changeValue} />
                    <MemorizedBtn text="Continue" />
                </div>
            )
        }

        ReactDOM.render(<App />, root)
    </script>
</html>
